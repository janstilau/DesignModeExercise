//
//  Prototype.h
//  DesignMode
//
//  Created by jansti on 2017/9/1.
//  Copyright © 2017年 jansti. All rights reserved.
//

#ifndef Prototype_h
#define Prototype_h

/*
 陈硕
 Prototype 的意义在于，你拿到一个 Base* ，它指向某个 Derived 对象，你想克隆出 Derived 对象，但代码中不写出 Derived 的具体类型，因为有很多派生类，这种情况下你用构造函数是搞不定的，type-switch 是 bad smells 。
 另外，这里考虑 virtual 的性能损失是主次不分，构造对象需要分配内存，这开销比一次虚函数调用大多了。
 Prorobuf Message 就采用了 prototype 模式，你可以参考一下。
 
 之前的设计模式,总结出了一个简单的结论.我们控制多态,只能通过控制内存.
 原型模式就是这样的一个例子.作为代价,它需要你所有的产品,都实现一个clone函数,这个克隆函数和copy构造方法有什么区别呢.这个clone函数里
 ,可以直接调用copy构造方法.但是这个clone函数是接口函数,可以用父类指针调用,copy构造函数却不可以.
 gof里面,原型设计模型,实现了抽象工厂方法的效果.首先,所有的产品,都实现了clone函数,返回自己类的一个副本,然后将这些原型,注册到了一个
 prototypeFactory的地方.我们注册什么,这个factory就返回什么.我们注册哪一个子类的对象,就返回哪一个子类.这样,就可以实现产品的动态配置,这中如果抽象工厂怎么做,要写一个工厂类,然后工厂类返回固定的产品.产品要成系列,一个工厂只能返回特定系列的产品.
 现在用了原型模式,注册什么子类产品,返回的就是什么子类产品.
 所以产品类可以减少类的个数,避免产品了工厂类的那个继承体系.而且,我们可以动态的配置产品了.
 设想,用户可以选择要什么产品,在选择完之后,我们生产一个工厂,工厂里面注册用户选择的产品.这样的需求,抽象工厂实现不了,因为产品系列都是写
 死的.但是,这种模式,在动态语言里很好实现,获得选择的产品的class对象,实例化一个对象就可以了.但是c++这种静态语言没有这种特点,原型
 模式就很重要了.
 还得注意的一点就是,copy了之后,要不要赋初值.之前的赋初值都是在构造方法里面,但是现在没有用构造方法,如果要赋初值的话,那么接口里面要留出赋值的接口.
 */


#endif /* Prototype_h */
