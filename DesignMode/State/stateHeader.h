//
//  stateHeader.h
//  DesignMode
//
//  Created by jansti on 2017/8/24.
//  Copyright © 2017年 jansti. All rights reserved.
//

#ifndef stateHeader_h
#define stateHeader_h


/* 
 
 在重构的第一章里面,运用了state模式.在那里,不同的影片有着不同的计算租金的规则.也有着一个枚举值来判断影片的状态.
 首先,运用继承是因为,运用方法非常长的switch 语句,会使得计算租金的这个方法变得责任过于重大.任何需要改变计算规则的需求改动,
 都要去修改这个方法,而这个方法的改动,会影响到了其他的计算规则.也就是,小改动会污染之前的代码.风险过大.
 解决这个问题的方法就是继承,不将计算方法统一放置,而是根据类型多态,将计算方法放置到不同的类的代码里面.
 既然继承能解决问题,为什么那里又用了状态模式了.因为对象不能动态的改变自己的类型,而那个环境下,影片可能会改变自己的类型.例如,从
 新发性的影片变为一般影片.原来的enum控制的方式,也就是改一下type的值,然后在一个长长的switch方法里面可以重新计算.
 但是现在是根据类型来获取最终结果,而无法改变自身的类型.
 于是,在重构的例子中,是选用了状态模式,计算的方法,放置到了状态的类等级系统中.每次影片改变type,会生成一个新的状态.影片计算租金的
 方法,代理给内部的状态对象.
 那么可以这样理解,一个类的功能,需要差异化,那么这个类就将这个差异化的过程交给了另外一个类体系.然后,这个类需要能控制,什么时候,
 用这个体系的什么对象.
 之所以要引入这个对象,是因为这个类,没有办法在运行时改变自己的类型,也就不能再运行时改变自己的行为.但是可以改变自己的成员变量,于是 
 改变这个事情,就交给了成员变量实现了.
 
 运用状态的时机
 <1> 根据状态改变行为的代码,不能放在一个长长的switch,或者if判断组成的方法里.应该代码分割减少危险.如果多个方法都要做这个判断,那么这个判断的代码就要在多个方法出现,冗余.
 <2> 需要在运行时改变自己的行为,这静态语言做不到.动态语言可以,但是也不应该做.所以需要通过修改成员变量的方式,修改自己的代理.
 
 需要考虑的点:
 1. 状态的改变.
    如果由状态的所有者管理状态的改变.可以在状态没有联系的状态下.例如,图书的type的改变,但是像tcp链接状态这种有序的状态改变,还是
 交由状态决定自己接下来的状态比较好.
 2. 状态是动态生成还是一直存在.如果状态一直改变,其实可以一直保存状态,尤其是状态如果没有保存太多的信息.一般来说,状态模式的状态,是为了改变行为,所以由他保存的数据不会太多.但是如果状态很少改变,并且保存很多数据,那么时用时销更好.
 3. 状态模式,也可以是通过组合方式实现动态继承的一种表示.
 
 
 
 */


#endif /* stateHeader_h */
