//
//  Facade.h
//  DesignMode
//
//  Created by jansti on 2017/8/30.
//  Copyright © 2017年 jansti. All rights reserved.
//

#ifndef Facade_h
#define Facade_h

/*
 
    当我们为了实现一个功能的时候,习惯于将这个功能实现的强大一些.比如,你想写一个通用的网络连接失效的时候展示的页面.这个时候可能有很多
 需要考虑,要不要把失效的图片的接口暴露出去,要不要把点击的回调函数的接口暴露出去,要不要把文字暴露出去.... 于是,你写了一个很复杂的接口
 ,这个接口,包含了所有可配置的元素,那么别人怎么调用这个接口呢,就要把所有的东西全部设置过去. 
    但是很多都是通用的啊,所以可以写一个简单的init的接口,返回默认的界面,但是在interface里面把配置的接口暴露出去,如果想要配置,可以
 单独配置. 所以用户在使用的时候,就很容易使用了.如果想要单独配置,也可以单独配置.
    
    如果这个功能很复杂,写了很多类,这个功能的实现,要A a, B b, C c, a dosth, b dosthwitha的结果, c dosthwithb的结果, 不同的
 类有着不同的功能,他们之间相互合作才能有结果.a,b,c 又能配置,比如可以配置类似程度,等级的数值,会对返回结果有影响. 那我们应该把什么给客
 户类使用呢.把A,B,C都暴露出去吗.客户类绝大部分时候,可能会用默认的配置.所以我们可以写一个resultGenerator的类,里面的getResult方法
 里面,依次生成a,b,c,调用方法,然后返回结果.
    这种代码,平时也写了很多次了.这就是外观facade模式.
 
    对于这个功能实现的类的集合,可以看做是一个子系统,这个子系统之间的类互相依赖紧密,因为各个类就是为了实现这个特定的功能诞生的,没有问
 题.但是对于这个类的使用者来说,它并不需要了解这个子系统的具体的细节.如果有一个facade挡在client,subsystem中间做媒介,那么相当于子
 系统被隔离了.甚至于子系统的功能完全被重写了,但是facade的接口没有变,client那的代码还是不用改变.
 但是client可能也有特殊化配置的时候,这个时候,client还可以自己去配置各个类的数据,至于facade里面留不留这种配置的接口,就要看facade
 的功能想要多强大.可以将执行特殊化的过程完全交给client,也可以自己留出特殊化的接口,只把特殊化的几个接口暴露出去,操作的过程,还是封装在
 facade内部.
 
 
 
 */



#endif /* Facade_h */
