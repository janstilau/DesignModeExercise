//
//  adapater.h
//  DesignMode
//
//  Created by justin lau on 2017/8/29.
//  Copyright © 2017年 jansti. All rights reserved.
//

#ifndef adapater_h
#define adapater_h

/*
 因为class Adapater 只有c++多重继承才能出现.所以我们只考虑object adapater.
    适配器模式用在改写类的接口,使得类符合某些接口.
    一般来说,使用适配器要在维护阶段.因为在开发阶段,就应该使得接口进行统一.
    A类,是一个已经实现好的现成的类,但是它的接口不符合现在功能的需要,A类也不好修改,因为A类已经在其他地方进行使用了.
 一般我们都用objact方式的适配器.这个时候,我们创造一个adapter类,在这个类的构造方法里面,传入一个A的实例进去,然后让
 adapater类实现接口.在接口的实现代码里面,利用A类的这个实例,如果可以直接代理给这个实例就代理过去,如果需要添加一些前置
 或者后续操作,就添加.如果是一些A没有的功能,就添加在adapter的实现里面.总之,是要打造一个符合现在功能要求的实现类,但是
 依靠A的实例进行实现的.一般来说,一个adapter里面,会有一个A的实例.
    适配器可以也可以当做一个差异化的过程,假如有一个数据类,很底层.然后不同的业务其实要求不同的表现,那么数据类的适配器
 可以将在不伤害数据类的前提下,做出不同的接口出来.
 
 
    two-way adapters
    有可能,一个数据类,是要被用到两个接口不同的地方.这个时候,可以将原来数据类的接口,也写在adapter里面,这样,可以实现
 两处都用一个adapter,实际访问的,也是同一个数据.
 */


#endif /* adapater_h */
