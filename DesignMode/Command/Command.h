
//
//  Command.h
//  DesignMode
//
//  Created by jansti on 2017/8/30.
//  Copyright © 2017年 jansti. All rights reserved.
//

#ifndef Command_h
#define Command_h

/*
 
    command模式
    command模式最大的特点,就是将请求和请求的执行者包装了起来.
    我们之前的button的回调,是一个函数指针,当button被点击了之后,就去调用相应的方法.这样的一种模式,是没有办法完成记录的功能的.
 对于复杂的操作,尤其是现在的软件普遍有的命令历史面板这种需求,在点击按钮之后,就去调用某些方法,这样虽然可以实现功能,但是最终记录下的只是
 一个状态,操作的顺序,中间的状态这些都不能被记录.这个时候,我们想要记录,就需要有一个实例,去记录,谁调用方法,调用什么方法,参数是什么.这
 些东西都需要被记录在内存里面,所以,command类就是为了实现这个目的被创造出来的.
    command类的内部,封装了调用者和调用方法,如果要实现undo redo的话,内部存储调用前的状态用于复原.command也可以用composite模式
 进行实现,一个有着子command的command作为一个macro Command存在.有了这些,我们就能用一个栈将这些对象存储过来.这个栈,就是顺序.方法
 的调用,一个函数的调用,是没有办法被记录下来的.能够记录下来的只有数据,而这些数据,可以用来表示这个调用的过程.及谁被调用,调用什么,参数是
 什么.
    而且还有一点,对于这种需要command的操作的场景,操作的对象,应该是可以通过applicaiton 访问到的对象.这个对象,一般来说会被app记录
 着.所以在创造这个command的时候,可以不传入receiver的参数,在command内部就行读取.不同子类的command,完成不同的功能.对于需要合并的
 ,可以在子类内部填写合并相关的函数.不同子类,也实现不同的undo,redo的状态的存储.但是,他们都要有的功能就是,记录调用者,调用方法,调用函
 数,通过一个对象,将这些记录下来.我们可以操作的,只有内存里的对象.
 
 1 command的触发证不一定要知道request的接受者
 2 封装成对象以便存储在队列里面
 3 可以通过composite组成macroCommand
 4 decouple command的触发者和实际的操作的执行者.按照btn回调的方式,实际的调用代码就只能写到btn的回调里面了.
 
 */





#endif /* Command_h */
